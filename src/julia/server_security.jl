module ServerSecurity

import HTTP
import MbedTLS

export SecurityContext, Get32BytePaddedPassword, HandleGetNonce,
       HandleEncryptedMessage, SendEncryptedMessage

struct SecurityContext
  padded_password::String
  used_nonces::Set{UInt64}

  SecurityContext(password) = 
      new(Get32BytePaddedPassword(password), Set{UInt64}())
end

function Get32BytePaddedPassword(password::String)
  if length(password) > 32
    error("Password must be less than or equal to 32 characters long.")
  end
  return password * ("0" ^ (32 - length(password)))
end

function ValidateNonce!(security_context::SecurityContext, nonce::UInt64)
  # Make sure the nonce has not been previously used.
  if nonce in security_context.used_nonces
    @warn "Received nonce has already been used before."
    return false
  end

  # Check if the nonce is expired or not (the nonce was generated by a call
  # to time_ns()).
  kNonceExpirationTimeInSeconds = 5 * 60
  time_since_nonce_created_in_seconds = (Base.time_ns() - nonce) / 1000000000.0
  if time_since_nonce_created_in_seconds > kNonceExpirationTimeInSeconds
    @warn "An expired nonce was used."
    return false
  end

  # Remember that we used this nonce.
  push!(security_context.used_nonces, nonce)
  return true  
end

# Returns a 64-bit nonce derived from the monotonic clock.
function HandleGetNonce(req::HTTP.Request)
  out_buffer = IOBuffer()
  nonce = Base.time_ns()
  write(out_buffer, nonce)

  return HTTP.Response(200, take!(out_buffer))
end

function HandleEncryptedMessage(
    security_context::SecurityContext, plaintext_handler::Function,
    req::HTTP.Request)
  cipher_buffer = IOBuffer(HTTP.payload(req))
  ciphertext = read(cipher_buffer)
  plaintext = Vector{UInt8}()
  try
    plaintext = MbedTLS.decrypt(
        MbedTLS.CIPHER_AES_256_CBC, security_context.padded_password,
        ciphertext)
  catch e
    @warn "Error decrypting a message.  Password mismatch?"
    return HTTP.Response(403, "Error decrypting message.  Password mismatch?")
  end

  plain_buffer = IOBuffer(plaintext)
  nonce = read(plain_buffer, UInt64)

  if !ValidateNonce!(security_context, nonce)
    return HTTP.Response(403, "Invalid nonce.")
  end

  return plaintext_handler(read(plain_buffer))
end

function SendEncryptedMessage(password::String, nonce_url, message_url, message)
  nonce_response = HTTP.get(nonce_url)
  nonce = read(IOBuffer(HTTP.payload(nonce_response)), UInt64)

  buffer = IOBuffer()
  write(buffer, nonce)
  write(buffer, message)

  ciphertext = MbedTLS.encrypt(
      MbedTLS.CIPHER_AES_256_CBC, Get32BytePaddedPassword(password),
      take!(buffer))

  return HTTP.post(message_url, body=ciphertext)
end

end
